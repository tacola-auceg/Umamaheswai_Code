
/**
 * Module Name :UNL based Searching and Ranking
 *
 * Version     :2
 *
 * Date        :30th Jan 2012
 *
 * Description :UNL based Searching and Ranking
 *---------------------------------------------
 * It uses UNL based Index and the translated UNL graph, and searches for the matching Tamil documents. In addition it uses a Ranking algorithm based on frequency of occurrence of actual words, Concept, Concept-Relation, Concept-Relation-Concept along with associated information regarding its position in the document and Concept Co-occurrence.
 *
 * Current Version Description  : 
 * ------------------------------
 * In UNL Searching
 *	1.Complete UNL Subgraph Match
 *	2.Partial UNL Subgraph Match
 *	Searching in Concept-Relation-Concept index tree with both concepts of the expanded query
 * Use of cache to store recent query Query terms for ANDvishnu(iof>god)search results , handling multiple query words are also done
 * In UNL Ranking
 * Two level ranking
 * Higher level ranking 
 * Which is based on 
 *	Concept-Relation-Concept (CRC), Concept- Relation (CR) and Concepts (C ) and pos relation preferences
 * 	Actual query word, 
 * 	Actual concept word a
 * 	Expanded concept word priority
 * 	Named Entity ,Position Weight and Frequency of concepts and terms is also considered
 * Lower level ranking 
 * which is based on
 * 	Frequency of occurrence
 * 	Position of word
 *
 *------------------------------------------------------------------------------
 * Version History...
 * Version     :2.1
 * -----------------------------------------------------------------------------
 * Date                          : 12.12.2011
 * Changes from Previous Version (Phase II 1st PRSG):
 * Ranking logic fine tuned-Tags has been modified
* Database access
 * AND CRC logic
 * For conceptual query result-CONC tag added
 */
/*
 *------------------------------------------------------------------------------
 * Version History...
 * Version     :2.2
 * -----------------------------------------------------------------------------
 * Date                          : 30th Jan 2012
 * Search has been limited for multiple word queries with temple
 */


package org.apache.nutch.search.unl;

import org.apache.nutch.unl.*;
import org.apache.nutch.analysis.unl.ta.*;
import org.apache.nutch.analysis.unl.ta.database.*;
import java.lang.*;
import java.math.BigDecimal;
import java.io.*;
import java.util.*;
import org.hibernate.*;

public class search_UNL implements Serializable
{
	public static BinarySearchTree bstcrc=new BinarySearchTree();//Initialization of Concept-Relation-Concept Binary Search Tree of Index
 	public static BinarySearchTree bstcr=new BinarySearchTree(); //Initialization of Concept-Relation Binary Search Tree of Index
 	public static BinarySearchTree bstc=new BinarySearchTree(); //Initialization of Concept Binary Search Tree of Index

	public HeadNode temp3=new HeadNode();			//Initialization of Head Node of Index Tree
	public ConceptNode cpt1=new ConceptNode();		//Initialization of Concept Node of Index Tree
	public ConceptToNode ToCpt1=new ConceptToNode();	//Initialization of ToConceptNode of Index Tree

	public BinaryNextNode bnextcc=new BinaryNextNode();	//Initialization of the BinaryNextNode class which contains the concepts that 									has same hash value details
	public BinaryNode bNodecc=new BinaryNode(); //Initialization of the BinaryNode class which contains the indexed 				

        boolean flag_singleword=false;

	public DocNode d1=new DocNode(); //Initialization of DocNode which contains document identifier of all indexed concepts

        public offline o=new offline();	//Initialization of

	nodeDetails node_details=null; //Initialization of sub class node_details contains all the retrieved documents details 

	public static Hashtable fileList = null; //Used to Retrieve document url using document identifier
	public static Hashtable conList = null; //Used to Retrieve document url using document identifier
	public static Hashtable constraintList = null; 
	FinalLLImpl[]  llq=new FinalLLImpl[3]; //Multilist contains query translation output

	public static boolean check_index=true; //boolean check to avoid recursive loading of index for each user search 

	public static Hashtable hashtable_c,counter;//Used for query processing
	public static Hashtable hashtable_cnt;
	public static Hashtable cache=new Hashtable();//To maintain results in cache

	Hashtable table=new Hashtable();//To store only docid of two different concepts 

	Hashtable andFreq=new Hashtable(); //To store the frequency count of two different concepts

	TreeSet hlight=new TreeSet(); //TreeSet to specify which concept's needs to be highlighted in the snippet

	String c1pos,c2pos,tamil_c1,tamil_c2;//String that assigns concepts and it's equivalent tamil words 

	ArrayList rank,freqsort;//Arraylist for final ranking
	
	//ArrayList that stores the results seperately in order to differentiate two query words are concepts,Named Entity,query term and Expanded query terms
	ArrayList crc_QWQW_NElist,crc_QWCQW_NElist,crc_CQWQW_NElist,crc_CQWCQW_NElist,crc_QWQW_nonNElist,crc_QWCQW_nonNElist,crc_CQWQW_nonNElist,crc_CQWCQW_nonNElist;
	
	ArrayList crc_QWEQW_NElist,crc_EQWQW_NElist,crc_CQWEQW_NElist,crc_EQWCQW_NElist,crc_QWEQW_nonNElist,crc_EQWQW_nonNElist,crc_CQWEQW_nonNElist,crc_EQWCQW_nonNElist;
	ArrayList c1r_QW_NElist,c1r_CQW_NElist,c1r_EQW_NElist,c1r_QW_nonNElist,c1r_CQW_nonNElist,c1r_EQW_nonNElist;
	ArrayList c2r_QW_NElist,c2r_CQW_NElist,c2r_EQW_NElist,c2r_QW_nonNElist,c2r_CQW_nonNElist,c2r_EQW_nonNElist;
	ArrayList c1_QW_NElist,c1_CQW_NElist,c1_EQW_NElist,c1_QW_nonNElist,c1_CQW_nonNElist,c1_EQW_nonNElist;
	ArrayList c2_QW_NElist,c2_CQW_NElist,c2_EQW_NElist,c2_QW_nonNElist,c2_CQW_nonNElist,c2_EQW_nonNElist;
	ArrayList and_QWQW_list,and_QWCQW_list,and_CQWQW_list,and_CQWCQW_list,and_QWEQW_list,and_EQWQW_list,and_CQWEQW_list,and_EQWCQW_list;
	ArrayList crRelList,crcRelList,mwCList;

	TreeSet removeDup; //TreeSet for removing duplicate entries


	public double loadindexTime;
        public double getcrcresultTime;
        public double cr_unlsearchTime;
        public double getc1c2Time;
        public double andlogicTime;
        public double tagSortingTime;
        public double removeDuplicateTime;
        public double freqSortingTime;
        public double getNodeLinkTime;
        public double seperateTagTime;

        public int loadindexCnt;
        public int getcrcresultCnt;
        public int cr_unlsearchCnt;
        public int getc1c2Cnt;
        public int andlogicCnt;
        public int tagSortingCnt;
        public int removeDuplicateCnt;
        public int freqSortingCnt;
        public int getNodeLinkCnt;
        public static int seperateTagCnt;
	
	
	/**
	 * This is the method for Initializing necessary variables for UNL Search.
	 *
	 * 
	 */
	public void initialize()
	{
	rank=new ArrayList();
	removeDup=new TreeSet();
	hashtable_c=new Hashtable();
	freqsort=new ArrayList();
	cache=new Hashtable();
	counter=new Hashtable();
		
	crRelList=new ArrayList();
	crcRelList=new ArrayList();
	mwCList=new ArrayList();

	crc_QWQW_NElist=new ArrayList();
	crc_QWCQW_NElist=new ArrayList();
	crc_CQWQW_NElist=new ArrayList();
	crc_CQWCQW_NElist=new ArrayList();

	crc_QWQW_nonNElist=new ArrayList();
	crc_QWCQW_nonNElist=new ArrayList();
	crc_CQWQW_nonNElist=new ArrayList();
	crc_CQWCQW_nonNElist=new ArrayList();

	crc_QWEQW_NElist=new ArrayList();
	crc_EQWQW_NElist=new ArrayList();
	crc_CQWEQW_NElist=new ArrayList();
	crc_EQWCQW_NElist=new ArrayList();

	crc_QWEQW_nonNElist=new ArrayList();
	crc_EQWQW_nonNElist=new ArrayList();
	crc_CQWEQW_nonNElist=new ArrayList();
	crc_EQWCQW_nonNElist=new ArrayList();

	c1r_QW_NElist=new ArrayList();
	c1r_CQW_NElist=new ArrayList();
	c1r_EQW_NElist=new ArrayList();
	c1r_QW_nonNElist=new ArrayList();
	c1r_CQW_nonNElist=new ArrayList();
	c1r_EQW_nonNElist=new ArrayList();

	c2r_QW_NElist=new ArrayList();
	c2r_CQW_NElist=new ArrayList();
	c2r_EQW_NElist=new ArrayList();
	c2r_QW_nonNElist=new ArrayList();
	c2r_CQW_nonNElist=new ArrayList();
	c2r_EQW_nonNElist=new ArrayList();

	c1_QW_NElist=new ArrayList();
	c1_CQW_NElist=new ArrayList();
	c1_EQW_NElist=new ArrayList();
	c1_QW_nonNElist=new ArrayList();
	c1_CQW_nonNElist=new ArrayList();
	c1_EQW_nonNElist=new ArrayList();

	c2_QW_NElist=new ArrayList();
	c2_CQW_NElist=new ArrayList();
	c2_EQW_NElist=new ArrayList();
	c2_QW_nonNElist=new ArrayList();
	c2_CQW_nonNElist=new ArrayList();
	c2_EQW_nonNElist=new ArrayList();

	and_QWQW_list=new ArrayList();
	and_QWCQW_list=new ArrayList();
	and_CQWQW_list=new ArrayList();
	and_CQWCQW_list=new ArrayList();

	and_QWEQW_list=new ArrayList();
	and_EQWQW_list=new ArrayList();
	and_CQWEQW_list=new ArrayList();
	and_EQWCQW_list=new ArrayList();

	}
	/**
	 * This is the method for loading UNL index.
	 *
	 * "
	 */
	public void loadindex()
	{
		
		check_index = false;//once loaded boolean value will be false to avoid reloading of index for every time 

		loadindexCnt++;
		//bstc=offline.getc(); //load concept index tree 
		//bstcrc=offline.getcrc();//load concept-relation-concept index tree
		//bstcr=offline.getcr();//load concept-relation index tree
		
		try
	    	{   	
			FileInputStream fis=new FileInputStream("./crawl-unl/RecnoToURL.ser");
			//File Input Stream for reading the URL of the document identifers 
			ObjectInputStream ois=new ObjectInputStream(fis);				
			fileList=(Hashtable)ois.readObject();
			ois.close();//closing object stream 
			fis.close();//closing file stream
			
			
		}
		catch(Exception e)
		{
			fileList = new Hashtable();	
			
			e.printStackTrace();//To print the run time exception			
		} 
		try
	    	{   	
			FileInputStream fiscon=new FileInputStream("./crawl-unl/freqcon.ser");
			//File Input Stream for reading the URL of the document identifers 
			ObjectInputStream oiscon=new ObjectInputStream(fiscon);				
			conList=(Hashtable)oiscon.readObject();
			oiscon.close();//closing object stream 
			fiscon.close();//closing file stream
			
			
		}
		catch(Exception e)
		{
			conList = new Hashtable();	
			
			e.printStackTrace();//To print the run time exception			
		} 
		/*try
	    	{   	
			FileInputStream fiscon=new FileInputStream("./crawl-unl/placeconstraint.ser");
			//File Input Stream for reading the URL of the document identifers 
			ObjectInputStream oiscon=new ObjectInputStream(fiscon);				
			constraintList =(Hashtable)oiscon.readObject();
			oiscon.close();//closing object stream 
			fiscon.close();//closing file stream
			
			
		}
		catch(Exception e)
		{
			constraintList = new Hashtable();	
			
			e.printStackTrace();//To print the run time exception			
		} */
		
	}
	/**
	 * This is the method for Searching UNL index.
	 *
	 * @param queryWord user query term 
	 * @return an ArrayList that consists of document identifier,ranktag value,snippet and summary
	 */
	public ArrayList crc_UNLSearch(String queryWord, FinalLLImpl[] llq,Session session,Transaction trans) throws Exception
	{
		ArrayList rank3= new ArrayList(); //ArrayList which contains the Final result reside in this 
	
		int limiter=0; //To limit total number of expanded words for search

		long startTime=0;
        long endTime=0;
        long startingtime =0;
        long endtime = 0;
	boolean con_Only=false;
         String conid="";
         String tamilid="";
         
        FileWriter fw = new FileWriter("/root/Desktop/moduletimeSearch.csv",true);
        fw.write(queryWord+", ");
        initialize(); 
		querywordHashtable(llq);
		TreeSet set=new TreeSet();

		String relation,c1_qtag,mw_tag,c2,to_con_tag,c1,c1rc2,c1c2=null;
		//String variable used for assigning tags of query word,concept word,multiwords
		boolean crccheck=false;
		
		startingtime = System.nanoTime();
		if(check_index)
		{			
				loadindex();						//load the index                 
		}
		endtime=System.nanoTime();                
        double result = endtime - startingtime;		
		result = result / (Math.pow(10, 9));    			
		fw.write(BigDecimal.valueOf(result)+", ");
		
		
		startingtime = System.nanoTime();
		try
		{
		//	llq=TamilQueryGraph.multilist_UNLQuery();//get translated query
			TreeSet c2concpt=new TreeSet();//Tree set for c2 concept (to_concept)
			
			//////////System.out.println("Concept Size"+llq[0].Conceptsize() );
			if(llq[0].Conceptsize() == 1)
			{
			flag_singleword = true;
			}
			//if(!flag_singleword){
			for(int i=0;i<1;i++) //Interating the search process for each query and it's expansion
			{
				//for(int k=0;k<llq[i].Conceptsize();k++)
				//{
				
				temp3=llq[i].head;//Intializing the head pointer for the concept node
				cpt1=temp3.colnext;//Assigning the multilist concept node pointer to traverse in vertical
				//////System.out.println("cpt value :"+cpt1);

				while(cpt1 != null)
				{
					                 //   //////////System.out.println("concept in Miltilist[" + i + "] :" + c11.gn_word + "\t" + c11.uwconcept + "\t" + c11.queryTag);
						c1=cpt1.uwconcept.trim();//String that holds query concept
						c1pos=cpt1.poscheck.trim();//String that holds POS(Part Of Speech)tag
						ToCpt1=cpt1.rownext;//Assigning the multilist To concept node pointer to traverse in 										horizontal
						c1_qtag=cpt1.queryTag.trim();//String that holds query tag(QW/CW/EQW)
						mw_tag=cpt1.MWtag_Qw.trim();//String that holds Multiword query tag
						tamil_c1=cpt1.gn_word.trim();	//String that holds tamil word 
						if(ToCpt1!=null && !ToCpt1.uwtoconcept.equals("None"))//null check
						{
						crccheck =true;
						while(ToCpt1 != null)//Traveral of c2(To concept) Node
						{	
						limiter++;
							
						relation=ToCpt1.relnlabel;
						String to_con=llq[i].getconcept_vs_conceptid_query(ToCpt1.uwtoconcept.trim());
						String[] toc=to_con.split("&");
						c2=toc[0].toString().trim();
						 conid=toc[1].toString().trim();
						 tamilid=toc[2].toString().trim();
						
						if(!c1.equals(c2)){

						to_con_tag=llq[i].gettagvalue(c2).trim();
						tamil_c2=llq[i].gettamilword(c2).trim();
						c2pos=llq[i].getentityofuw(c2).trim();
						
						
						c2concpt.add(c2);
						//////////System.out.println(tamil_c1+c1pos+"*"+tamil_c2+c2pos);
						
									
						
						if(c1_qtag.equals("CQW")||c1_qtag.equals("EQW"))
						{
							tamil_c1=getQW(cpt1.uwconcept);
      							if(tamil_c1!=null)
							{
                                                               	c1_qtag="QW";
								
							}
														
						}
						if(to_con_tag.equals("CQW")||to_con_tag.equals("EQW"))
						{
							tamil_c2=getQW(c2);
							if(tamil_c2!=null)
							{
								to_con_tag="QW";
								
							}
						}
						if(set.add(c2))
						{
							

                                                        startTime=System.currentTimeMillis();
							
							   if((!(cpt1.poscheck.equals("Verb"))) && (!(cpt1.poscheck.equals("Finite Verb"))&& (!(cpt1.poscheck.equals("Adjective"))) && (!(cpt1.poscheck.equals("Particle"))) && (!(cpt1.poscheck.equals("Postposition")))&&(!(cpt1.poscheck.equals("Adjectival Noun"))) ))
							{
							
						if(!conList.containsKey(c2)&&!mw_tag.equals("MW"))//Limit the results for Temple concepts
						{
						//	System.out.println("yes it 's in the conLits");
							//StringTokenizer stcon=new StringTokenizer(c2,"()");

		//String qcon=stcon.nextToken();
	//	String conconstraint=stcon.nextToken();
		//if(constraintList.containsKey(conconstraint))
		//{
			getc1c2(c2,"c2",tamil_c2,c2pos,to_con_tag,"",session,trans,Integer.parseInt(conid),Integer.parseInt(tamilid));
		//}
		//else
		//{
		////c1c2check="c1";
		//}
							
						}
						
							
							}
                                                        endTime=System.currentTimeMillis();
                                                        getc1c2Time= (endTime-startTime)/1000.00;
						}
						if(set.add(c1))
						{
							
                                                        startTime=System.currentTimeMillis();
							//if(!c1pos.contains("Adjective")&&!c1pos.contains("Verb")&&!c1pos.contains("Finite Verb"))
							   if((!(cpt1.poscheck.equals("Verb"))) && (!(cpt1.poscheck.equals("Finite Verb"))&& (!(cpt1.poscheck.equals("Adjective"))) && (!(cpt1.poscheck.equals("Particle"))) && (!(cpt1.poscheck.equals("Postposition"))) && (!(cpt1.poscheck.equals("Adjectival Noun")))))
							{
							
	if(!conList.containsKey(cpt1.uwconcept)&&!cpt1.MWtag_Qw.trim().equals("MW"))//Limit the results for Temple concepts	
						{
                                                         	getc1c2(cpt1.uwconcept,"c1",tamil_c1,c1pos,c1_qtag,"",session,trans,Integer.parseInt(conid),Integer.parseInt(tamilid));//get only the concept and term matched results
						}
							
							}
                                                        endTime=System.currentTimeMillis();
                                                        getc1c2Time+= (endTime-startTime)/1000.00;
						}
						
                                  //  //System.out.println(tamil_c1+"*"+c1+relation+"*"+c2+tamil_c2+"*"+c1_qtag+"*"+to_con_tag+"*"+mw_tag);
						
						if(!c1pos.contains("Adjective")&&!c2pos.contains("Adjective"))
						{
						if(c1pos.contains("Entity")||c2pos.contains("Entity")){
						getcrcresult(tamil_c1,c1,relation,c2,tamil_c2,c1_qtag,to_con_tag,mw_tag,session,trans,Integer.parseInt(conid),Integer.parseInt(tamilid));
						}
						}
						
                                                        endTime=System.currentTimeMillis();
                                                        getcrcresultTime=(endTime - startTime)/1000.00;					
						
						
						
						
					}//c1c2 equals check
						
				ToCpt1=ToCpt1.getRowNext();//increment the to-concept node pointer
				
					
				}//while tocpt
				}//if tocpt not null
				
				else
				{
				con_Only = true;
				}		
				
		     		 cpt1=cpt1.getColNext();//increment the concept node pointer
				
			}//while of cpt
	
			//}//for
			
		} //for	
		//}//if for not single word query

				//If there is no relations exist between the concept do only the concept search in the index tree
		if(con_Only){
		for(int i=0;i<1;i++) //Interating the search process for each query and it's expansion
			{
			//	llq=TamilQueryGraph.multilist_UNLQuery();
				
					if(llq!=null){	
			
				temp3=llq[i].head;
				cpt1=temp3.colnext;
				
				while(cpt1 != null)
				{
						limiter++;
					
				
				        if((!(cpt1.poscheck.equals("Verb"))) && (!(cpt1.poscheck.equals("Finite Verb"))&& (!(cpt1.poscheck.equals("Adjective"))) && (!(cpt1.poscheck.equals("Particle"))) && (!(cpt1.poscheck.equals("Postposition")))&& (!(cpt1.poscheck.equals("Adjectival Noun"))) ))
					{
						if(c2concpt.add(cpt1.uwconcept.trim()))
						{
						
						startTime=System.currentTimeMillis();
						if(llq[0].Conceptsize()>2)
						{
						if(!conList.containsKey(cpt1.uwconcept)&&!cpt1.MWtag_Qw.trim().contains("MW"))
						{
						getc1c2(cpt1.uwconcept,"c1",cpt1.gn_word,cpt1.poscheck,cpt1.queryTag,cpt1.MWtag_Qw.trim(),session,trans,Integer.parseInt(cpt1.con_uid),Integer.parseInt(cpt1.tam_uid));
						}
						else
						{
						getc1c2(cpt1.uwconcept,"c1",cpt1.gn_word,cpt1.poscheck,cpt1.queryTag,cpt1.MWtag_Qw.trim(),session,trans,Integer.parseInt(cpt1.con_uid),Integer.parseInt(cpt1.tam_uid));
						}//If it is MW 
						}
						else
						{
						getc1c2(cpt1.uwconcept,"c1",cpt1.gn_word,cpt1.poscheck,cpt1.queryTag,cpt1.MWtag_Qw.trim(),session,trans,Integer.parseInt(cpt1.con_uid),Integer.parseInt(cpt1.tam_uid));
						}
                                                endTime=System.currentTimeMillis();
                                                getc1c2Time+= (endTime-startTime)/1000.00;
						}	
					}//if
					cpt1=cpt1.getColNext();
				}//
				
			}//for loop ends
			}
		}
	/*	c1r_QW_NElist.addAll(c1r_QW_nonNElist);  
		c1r_CQW_NElist.addAll(c1r_CQW_nonNElist);
		c1r_EQW_NElist.addAll(c1r_EQW_nonNElist);
		c2r_QW_NElist.addAll(c2r_QW_nonNElist);
		c2r_CQW_NElist.addAll(c2r_CQW_nonNElist);
		c2r_EQW_NElist.addAll(c2r_EQW_nonNElist);
				
		c1_QW_NElist.addAll(c1_QW_nonNElist);
		c1_CQW_NElist.addAll(c1_CQW_nonNElist);
		c1_EQW_NElist.addAll(c1_EQW_nonNElist);
		c2_QW_NElist.addAll(c2_QW_nonNElist);
		c2_CQW_NElist.addAll(c2_CQW_nonNElist);
		c2_EQW_NElist.addAll(c2_EQW_nonNElist);*/
		
		//AND of two concepts c1 and c2
		startTime =System.currentTimeMillis();
		andlogic(c1r_QW_NElist,c2r_QW_NElist,"xryr");
		andlogic(c1r_QW_nonNElist,c2r_QW_NElist,"xryr");				
		andlogic(c1r_QW_NElist,c2r_CQW_NElist,"xryr");	
		andlogic(c1r_QW_nonNElist,c2r_CQW_NElist,"xryr");		
		andlogic(c1r_CQW_NElist,c2r_QW_NElist,"xryr");	
		andlogic(c1r_CQW_nonNElist,c2r_QW_NElist,"xryr");			
		andlogic(c1r_CQW_NElist,c2r_CQW_NElist,"xryr");	
		andlogic(c1r_CQW_nonNElist,c2r_CQW_NElist,"xryr");
	
		andlogic(c1r_QW_NElist,c2_QW_NElist,"xry");		
		andlogic(c1r_QW_NElist,c2_CQW_NElist,"xry");		
		andlogic(c1r_CQW_NElist,c2_QW_NElist,"xry");		
		andlogic(c1r_CQW_NElist,c2_CQW_NElist,"xry");		
	

		andlogic(c2r_QW_NElist,c1_QW_NElist,"yrx");		
		andlogic(c2r_QW_NElist,c1_CQW_NElist,"yrx");		
		andlogic(c2r_CQW_NElist,c1_QW_NElist,"yrx");		
		andlogic(c2r_CQW_NElist,c1_CQW_NElist,"yrx");		
	
		
		
		andlogic(c1_QW_NElist,c2_QW_NElist,"xy");		
		andlogic(c1_QW_NElist,c2_CQW_NElist,"xy");			
		andlogic(c1_CQW_NElist,c2_QW_NElist,"xy");				
		andlogic(c1_CQW_NElist,c2_CQW_NElist,"xy");		
	
		
		
		ArrayList conly_list=new ArrayList();
		conly_list.addAll(c1_QW_NElist);
		conly_list.addAll(c1_QW_nonNElist);
		conly_list.addAll(c2_QW_NElist);
		conly_list.addAll(c2_QW_nonNElist);
		andlogicforconly(conly_list);
		


		ArrayList crc_list=new ArrayList();
		
		crc_list.add(crc_QWQW_NElist);
		crc_list.add(crc_QWQW_nonNElist);
		crc_list.add(crc_QWCQW_NElist);
		crc_list.add(crc_QWCQW_nonNElist);
		crc_list.add(crc_CQWQW_NElist);
		crc_list.add(crc_CQWQW_nonNElist);
		crc_list.add(crc_CQWCQW_NElist);
		crc_list.add(crc_CQWCQW_nonNElist);
	
		for(int r=0;r<crc_list.size();r++)
		{
			ArrayList al_list1=(ArrayList)crc_list.get(r);
			for(int s=r+1;s<crc_list.size();s++)
			{
			ArrayList al_list2=(ArrayList)crc_list.get(s);
			andlogic_crc(al_list1, al_list2, "xryx1ry1");
			}
			
			
		}
		
		endTime=System.currentTimeMillis();
                andlogicTime=(endTime-startTime)/1000.00;
		
		//adding all the results in the rank arraylist
		////////System.out.println("MWList"+mwCList.size());
		rank.addAll(mwCList);	

		rank.addAll(crc_QWQW_NElist);
		rank.addAll(crc_QWQW_nonNElist);
		rank.addAll(crc_QWCQW_NElist);
		rank.addAll(crc_QWCQW_nonNElist);
		rank.addAll(crc_CQWQW_NElist);
		rank.addAll(crc_CQWQW_nonNElist);
		rank.addAll(crc_CQWCQW_NElist);
		rank.addAll(crc_CQWCQW_nonNElist);
	

		rank.addAll(and_QWQW_list);
		rank.addAll(and_QWCQW_list);
		rank.addAll(and_CQWQW_list);
		rank.addAll(and_CQWCQW_list);
		/*rank.addAll(and_QWEQW_list);
		rank.addAll(and_EQWQW_list);
		rank.addAll(and_CQWEQW_list);
		rank.addAll(and_EQWCQW_list);*/

		
		rank.addAll(c1r_QW_NElist);
		rank.addAll(c2r_QW_NElist);
		rank.addAll(c1_QW_NElist);
		
		rank.addAll(c2_QW_NElist);
	

		rank.addAll(c1r_CQW_NElist);
		rank.addAll(c2r_CQW_NElist);
		rank.addAll(c1_CQW_NElist);
		rank.addAll(c2_CQW_NElist);
		rank.addAll(crc_QWEQW_NElist);
		rank.addAll(c1r_QW_nonNElist);
		rank.addAll(c2r_QW_nonNElist);
		rank.addAll(c1_QW_nonNElist);
		rank.addAll(c2_QW_nonNElist);
		rank.addAll(c1r_CQW_nonNElist);
		rank.addAll(c2r_CQW_nonNElist);
		rank.addAll(c1_CQW_nonNElist);
		rank.addAll(c2_CQW_nonNElist);		
		rank.addAll(crc_EQWQW_NElist);	
		rank.addAll(crc_CQWEQW_NElist);			
		rank.addAll(crc_EQWCQW_NElist);
		rank.addAll(crc_QWEQW_nonNElist);
		rank.addAll(crc_EQWQW_nonNElist);
		rank.addAll(crc_CQWEQW_nonNElist);
		rank.addAll(crc_EQWCQW_nonNElist);

	////////////////System.out.println("Before giving to rank sorting size"+rank.size());
		//passing rank arraylist in the tag sorting
		rank=tagSorting(rank);
		/*startTime=System.currentTimeMillis();
		rank=c1_QW_NElist(rank);
                endTime=System.currentTimeMillis();
                tagSortingTime=(endTime-startTime)/1000.00;	*/
		
		//removing duplicates of results
		//*ArrayList rank1=removeDuplicateWithOrder(rank);
		startTime=System.currentTimeMillis();
		ArrayList rank1=removeDuplicateWithOrder(rank);
                endTime=System.currentTimeMillis();
                removeDuplicateTime=(endTime-startTime)/1000.00;
		
		//sorting with respect to frequency count and position weight of concepts
		//*ArrayList rank2=Freq_Sorting(rank1);
		startTime=System.currentTimeMillis();
		ArrayList rank2=Freq_Sorting(rank1);
                endTime=System.currentTimeMillis();
                freqSortingTime=(endTime-startTime)/1000.00;
		
		//get node URl and generate snippet 
		
		startTime=System.currentTimeMillis();
		rank3=getNodeLink(rank2);
                endTime=System.currentTimeMillis();
                getNodeLinkTime=(endTime-startTime)/1000.00;



		//Seperate the tag for matrix display and return the final ranked results 
		
		startTime=System.currentTimeMillis();
		rank3=seperateTag(rank3);
                endTime=System.currentTimeMillis();
                seperateTagTime=(endTime-startTime)/1000.00;		
	}
	 catch(Exception e)
	{
		//////////////System.out.println("Exception in CRC search"); 
		e.printStackTrace();
	}
	 endtime=System.nanoTime();                
     result = endtime - startingtime;		
	 result = result / (Math.pow(10, 9));    			
	 fw.write(BigDecimal.valueOf(result)+",\n "); 

	 fw.close();
		
		return rank3;
	}// method end






	/**
	 * This is the method for getting concept -relation-concept results
	 *
	 * @param bNodecc BinaryNode of Matched concept
	 * @param c1rc2 String concept1-relation-concept2 query
	 * @param c1c2 String concept1-concept2(c1-c2) query 
	 * @param c1_qtag String concept1 querytag
	 * @param to_con_tag String concept2 querytag
	 * @param mwtag multiword querytag
	 */
	/*public void getcrcresult(String c1tamil,String con,String relation,String tocon,String c2tamil,String c1_qtag,String to_con_tag,String mwtag,Session sessioncrc,Transaction transactioncrc)
	{
	//	org.apache.nutch.analysis.unl.ta.database.DBConnection dbConnectioncrc = new org.apache.nutch.analysis.unl.ta.database.DBConnection();
		sessioncrc = HibernateUtil.getSessionFactory().openSession();
		List<CRCNode> courses = null;
		List<CRCInfo> crc_inf = null;
//		Transaction transactioncrc = null;
		int fromconceptid=0;
		int toconceptid=0;
		boolean flagRelation=false;
		boolean tamilword_checkc1=false;
		boolean nec1=false;
		boolean tamilword_checkc2=false;
		boolean nec2=false;
	
		int sentenceidcrc = 0;
		int crc_weight=	0;	
		int crc_frequency=0;
		int docid_crc=0;
		String sentid_crc="";
		String ind_con="";
		String ind_relation="";
		String ind_tocon="";
		String str_tamil="";
			String str_tamil2="";
		int crcid = 0;
		try {
			transactioncrc = sessioncrc.beginTransaction();

List<CRCNodeExt> getCRCNodeinfo = (List<CRCNodeExt>) sessioncrc.createQuery("from CRCNodeExt where touwconcept= '"+tocon+"'").list();				
			for (Iterator<CRCNodeExt> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCNodeExt crcnodeext = (CRCNodeExt) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,tamil_c2);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,tamil_c1);
			ind_relation=crcnodeext.getRelation();
			int crcinfoid = crcnodeext.getCrcid();
	////////System.out.println("nec1"+nec1+"\t"+nec2);

     if (nec1==true || nec2==true)
    {
	List<CRCInfoExt> getCRCinfo = (List<CRCInfoExt>) sessioncrc.createQuery("from CRCInfoExt where crcid='" +crcinfoid  + "'").list();
			for (Iterator<CRCInfoExt> iteratorcrc = getCRCinfo.iterator(); iteratorcrc.hasNext();) {
				CRCInfoExt crcnodeextcrc = (CRCInfoExt) iteratorcrc.next();
                         // String sentid= Integer.toString(crcnodeextcrc.getSentenceid());
			crc_weight=	crcnodeextcrc .getWeight();		
			crc_frequency= crcnodeextcrc.getFrequencycount();
			docid_crc= crcnodeextcrc.getDocumentid();
			sentenceidcrc= crcnodeextcrc.getSentenceid();
			

			try{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}catch(Exception e){e.printStackTrace();}
			
		
			}//for
		}
		}//for//End of CRC Match
	List<CRCNodeExt> getC1RNodeinfo =null;
	List<CRCNodeExt> getC2RNodeinfo =null;
if(con != null && tocon!=null){
if(!con.contains(">temple")&&!con.contains("MW")&&!con.contains(">facilities")&&!con.contains("aoj>thing")&&!con.equals("base(agt>thing)"))//Limit the results for Temple concepts
{
 getC1RNodeinfo = (List<CRCNodeExt>) sessioncrc.createQuery("from CRCNodeExt where fromuwconcept = '"+con+"' ").list();		
 getC2RNodeinfo = (List<CRCNodeExt>) sessioncrc.createQuery("from CRCNodeExt where touwconcept = '"+tocon+"' ").list();	
}else{}
	
}
if( getC1RNodeinfo!=null &&  getC2RNodeinfo!=null){
for (Iterator<CRCNodeExt> iteratorcr =  getC1RNodeinfo .iterator(); iteratorcr.hasNext();) {
				CRCNodeExt c1rnodeext = (CRCNodeExt) iteratorcr.next();
				String tamil_wrdc1=c1rnodeext.getFromtamilconcept();
				int c1rinfoid =c1rnodeext.getCrcid();	
				ind_relation=c1rnodeext.getRelation();

			List<CRCInfoExt> getCRCinfo = (List<CRCInfoExt>) sessioncrc.createQuery("from CRCInfoExt where crcid='" +c1rinfoid  + "'").list();
			for (Iterator<CRCInfoExt> iteratorc1r= getCRCinfo.iterator(); iteratorc1r.hasNext();) {
				CRCInfoExt crcnodeextcrc = (CRCInfoExt) iteratorc1r.next();
			crc_weight=	crcnodeextcrc .getWeight();		
			crc_frequency= crcnodeextcrc.getFrequencycount();
			docid_crc= crcnodeextcrc.getDocumentid();
			sentenceidcrc= crcnodeextcrc.getSentenceid();
			////System.out.println("List of documents"+crc_weight+"\t"+crc_frequency+"\t"+docid_crc+"\t"+"*"+"\t"+con+"\t"+"*"+"\t"+sentid_crc+"\t"+tamil_wrdc1+"\t"+"*");
			node_details = new nodeDetails();
			if(tamil_wrdc1 != null)
			node_details.construtObject(crc_weight,crc_frequency,docid_crc,"",con,"",sentid_crc,tamil_wrdc1,"");
			if((ind_relation).equals(relation))
					{
						
					 process_cr(tamilword_checkc1,nec1,true,"c1",c1_qtag,mwtag);
					
					}else 
					{
						 process_cr(tamilword_checkc1,nec1,false,"c1",c1_qtag,mwtag);
						
					
					}
			
		
			}//for
}//for

for (Iterator<CRCNodeExt> iteratorcr1 = getC2RNodeinfo.iterator(); iteratorcr1.hasNext();) {
				CRCNodeExt c2rnodeext = (CRCNodeExt) iteratorcr1.next();
					String tamil_wrdc2=c2rnodeext.getTotamilconcept();
				int c2rinfoid = c2rnodeext.getCrcid();
				ind_relation=c2rnodeext.getRelation();
				List<CRCInfoExt> getCRCinfo = (List<CRCInfoExt>) sessioncrc.createQuery("from CRCInfoExt where crcid='" +c2rinfoid  + "'").list();
			for (Iterator<CRCInfoExt> iteratorc2r= getCRCinfo.iterator(); iteratorc2r.hasNext();) {
				CRCInfoExt crcnodeextcrc = (CRCInfoExt) iteratorc2r.next();
			crc_weight=	crcnodeextcrc .getWeight();		
			crc_frequency= crcnodeextcrc.getFrequencycount();
			docid_crc= crcnodeextcrc.getDocumentid();
			sentenceidcrc= crcnodeextcrc.getSentenceid();
                      // String sentid= Integer.toString(docinfo.getSentenceid());
                          if(tamil_wrdc2 != null)
	node_details.construtObject(crc_weight,crc_frequency,docid_crc,"",tocon,"",sentid_crc,tamil_wrdc2,"");
			if((ind_relation).equals(relation))
					{
						
					 process_cr(tamilword_checkc2,nec2,true,"c2", to_con_tag,mwtag);
					
					}else 
					{
						 process_cr(tamilword_checkc2,nec2,false,"c2", to_con_tag,mwtag);
						
					
					}
			////////////System.out.println("List of documents"+str_tamil2+":"+str_tamil+docid_crc);
			}//for
}//for

	//C1R Match

}
			

			transactioncrc.commit();
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
	}

	*/
	public void getc1c2(String con,String check,String tamil,String pos,String qtag,String mwtag, Session session, Transaction transaction,int uwconceptid,int uwtamilid)
	{
		node_details=new nodeDetails();
	

		boolean flag_tamil=false;
		boolean flag_NE=false;
		 session = HibernateUtil.getSessionFactory().openSession();

		int sentenceid = 0;
		int synid=0;
		String str_tamil="";
		List<UWDictionary> nodeinfo=null;
		try {
			
			transaction = session.beginTransaction();
			int uwconid=uwconceptid/10000;
			switch(uwconid)
			{
				case 0:
					
				nodeinfo = (List<UWDictionary>) session.createQuery("from UWDictionary where uwconcept='"+con+"'").list();	
				
				for (Iterator<UWDictionary> iterator = nodeinfo.iterator(); iterator.hasNext();) {
					UWDictionary uwinfo = (UWDictionary) iterator.next();				
					synid=uwinfo.getTamilwordid();
					str_tamil=uwinfo.getSynonym();
					//System.out.println("str_tamil"+str_tamil+synid);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
					
				List<ConceptInfo> doc_inf =  (List<ConceptInfo>)session.createQuery("from ConceptInfo where tamilwordid = "+synid).list();
				////System.out.println("docinfo"+doc_inf);
				for (Iterator<ConceptInfo> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				ConceptInfo docinfo = (ConceptInfo) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				
				int freqdb=docinfo.getTermfrequency()+docinfo.getConceptfrequency();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());
				//System.out.println(dociddb);
		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				//////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				}//for
				}//for
				break;
	
				case 1:
				nodeinfo = (List<UWDictionary>) session.createQuery("from UWDictionary where uwconcept='"+con+"'").list();	
				
				for (Iterator<UWDictionary> iterator = nodeinfo.iterator(); iterator.hasNext();) {
					UWDictionary uwinfo = (UWDictionary) iterator.next();				
					synid=uwinfo.getTamilwordid();
					str_tamil=uwinfo.getSynonym();
					//System.out.println("str_tamil"+str_tamil+synid);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
					
				List<ConceptInfo1> doc_inf =  (List<ConceptInfo1>)session.createQuery("from ConceptInfo1 where tamilwordid = "+synid).list();
				//System.out.println("docinfo"+doc_inf);
				for (Iterator<ConceptInfo1> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				ConceptInfo1 docinfo = (ConceptInfo1) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				
				int freqdb=docinfo.getTermfrequency()+docinfo.getConceptfrequency();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());
				//System.out.println(dociddb);
		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				//////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				}//for
				}//for
				break;
	

			
				case 2:
				
				nodeinfo = (List<UWDictionary>) session.createQuery("from UWDictionary where uwconcept='"+con+"'").list();	
				
				for (Iterator<UWDictionary> iterator = nodeinfo.iterator(); iterator.hasNext();) {
					UWDictionary uwinfo = (UWDictionary) iterator.next();				
					synid=uwinfo.getTamilwordid();
					str_tamil=uwinfo.getSynonym();
					//System.out.println("str_tamil"+str_tamil+synid);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
					
				List<ConceptInfo2> doc_inf =  (List<ConceptInfo2>)session.createQuery("from ConceptInfo2 where tamilwordid = "+synid).list();
				//System.out.println("docinfo"+doc_inf);
				for (Iterator<ConceptInfo2> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				ConceptInfo2 docinfo = (ConceptInfo2) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				
				int freqdb=docinfo.getTermfrequency()+docinfo.getConceptfrequency();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());
				//System.out.println(dociddb);
		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				//////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				}//for
				}//for
				break;
				case 3:
				
				nodeinfo = (List<UWDictionary>) session.createQuery("from UWDictionary where uwconcept='"+con+"'").list();	
				
				for (Iterator<UWDictionary> iterator = nodeinfo.iterator(); iterator.hasNext();) {
					UWDictionary uwinfo = (UWDictionary) iterator.next();				
					synid=uwinfo.getTamilwordid();
					str_tamil=uwinfo.getSynonym();
					//System.out.println("str_tamil"+str_tamil+synid);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
					
				List<ConceptInfo3> doc_inf =  (List<ConceptInfo3>)session.createQuery("from ConceptInfo3 where tamilwordid = "+synid).list();
				//System.out.println("docinfo"+doc_inf);
				for (Iterator<ConceptInfo3> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				ConceptInfo3 docinfo = (ConceptInfo3) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				
				int freqdb=docinfo.getTermfrequency()+docinfo.getConceptfrequency();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());
				//System.out.println(dociddb);
		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				//////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				}//for
				}//for
				break;
				case 4:
				
				nodeinfo = (List<UWDictionary>) session.createQuery("from UWDictionary where uwconcept='"+con+"'").list();	
				
				for (Iterator<UWDictionary> iterator = nodeinfo.iterator(); iterator.hasNext();) {
					UWDictionary uwinfo = (UWDictionary) iterator.next();				
					synid=uwinfo.getTamilwordid();
					str_tamil=uwinfo.getSynonym();
					//System.out.println("str_tamil"+str_tamil+synid);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
					
				List<ConceptInfo4> doc_inf =  (List<ConceptInfo4>)session.createQuery("from ConceptInfo4 where tamilwordid = "+synid).list();
				//System.out.println("docinfo"+doc_inf);
				for (Iterator<ConceptInfo4> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				ConceptInfo4 docinfo = (ConceptInfo4) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				
				int freqdb=docinfo.getTermfrequency()+docinfo.getConceptfrequency();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());
				//System.out.println(dociddb);
		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				//////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				}//for
				}//for
				break;
			
			}
			
			transaction.commit();
		} catch (HibernateException e) {
			transaction.rollback();
			e.printStackTrace();
		} finally {
			session.close();
		}

		
	}
	public void getcrcresult(String c1tamil,String con,String relation,String tocon,String c2tamil,String c1_qtag,String to_con_tag,String mwtag,Session sessioncrc,Transaction transactioncrc,int uwconceptid,int uwtamilid)
	{
	//	org.apache.nutch.analysis.unl.ta.database.DBConnection dbConnectioncrc = new org.apache.nutch.analysis.unl.ta.database.DBConnection();
		sessioncrc = HibernateUtil.getSessionFactory().openSession();
		//List<CRCNode> courses = null;
		//List<CRCInfo> crc_inf = null;
//		Transaction transactioncrc = null;
	

	int fromconceptid=0;
		int toconceptid=0;
		boolean flagRelation=false;
		boolean tamilword_checkc1=false;
		boolean nec1=false;
		boolean tamilword_checkc2=false;
		boolean nec2=false;
	
		int sentenceidcrc = 0;
		int crc_weight=	0;	
		int crc_frequency=0;
		int docid_crc=0;
		String sentid_crc="";
		String ind_con="";
		String ind_relation="";
		String ind_tocon="";
		String str_tamil="";
		String str_tamil2="";
		int crcid = 0;
		TreeSet ts=new TreeSet();
		
			int conidrange=uwconceptid/10000;
		switch(conidrange)
		{
		case 0:
		try {
			transactioncrc = sessioncrc.beginTransaction();
			List<CRCTable1> getCRCNodeinfo = (List<CRCTable1>) sessioncrc.createQuery("from CRCTable1 where fromuwconcept='"+con+"' and touwconcept= '"+tocon+"'").list();
			for (Iterator<CRCTable1> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCTable1 crcnodeext = (CRCTable1) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,c2tamil);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,c1tamil);
			ind_relation=crcnodeext.getRelation();


			crc_weight=	crcnodeext.getWeight();		
			crc_frequency= crcnodeext.getTermfrequency();
			docid_crc= crcnodeext.getDocumentid();
			sentenceidcrc= crcnodeext.getSentenceid();
			

			try{
			if(ts.add(Integer.toString(docid_crc)+con+tocon))
			{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}//if
			}catch(Exception e){e.printStackTrace();}
			}//for ends

			
		transactioncrc.commit();
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
		break;

		case 1:
			try {
			transactioncrc = sessioncrc.beginTransaction();
			List<CRCTable2> getCRCNodeinfo = (List<CRCTable2>) sessioncrc.createQuery("from CRCTable2 where fromuwconcept='"+con+"' and touwconcept= '"+tocon+"'").list();
			for (Iterator<CRCTable2> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCTable2 crcnodeext = (CRCTable2) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,c2tamil);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,c1tamil);
			ind_relation=crcnodeext.getRelation();


			crc_weight=	crcnodeext.getWeight();		
			crc_frequency= crcnodeext.getTermfrequency();
			docid_crc= crcnodeext.getDocumentid();
			sentenceidcrc= crcnodeext.getSentenceid();
			

			try{
			if(ts.add(Integer.toString(docid_crc)+con+tocon))
			{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}//if
			}catch(Exception e){e.printStackTrace();}
			}//for ends

		
		transactioncrc.commit();
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
		break;

		case 2:
				try {
			transactioncrc = sessioncrc.beginTransaction();
			List<CRCTable3> getCRCNodeinfo = (List<CRCTable3>) sessioncrc.createQuery("from CRCTable3 where fromuwconcept='"+con+"' and touwconcept= '"+tocon+"'").list();
			for (Iterator<CRCTable3> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCTable3 crcnodeext = (CRCTable3) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,c2tamil);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,c1tamil);
			ind_relation=crcnodeext.getRelation();


			crc_weight=	crcnodeext.getWeight();		
			crc_frequency= crcnodeext.getTermfrequency();
			docid_crc= crcnodeext.getDocumentid();
			sentenceidcrc= crcnodeext.getSentenceid();
			

			try{
			if(ts.add(Integer.toString(docid_crc)+con+tocon))
			{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}//if
			}catch(Exception e){e.printStackTrace();}
			}//for ends

		transactioncrc.commit();
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
		break;

		case 3:
			try {
			transactioncrc = sessioncrc.beginTransaction();
			List<CRCTable4> getCRCNodeinfo = (List<CRCTable4>) sessioncrc.createQuery("from CRCTable4 where fromuwconcept='"+con+"' and touwconcept= '"+tocon+"'").list();
			for (Iterator<CRCTable4> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCTable4 crcnodeext = (CRCTable4) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,c2tamil);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,c1tamil);
			ind_relation=crcnodeext.getRelation();


			crc_weight=	crcnodeext.getWeight();		
			crc_frequency= crcnodeext.getTermfrequency();
			docid_crc= crcnodeext.getDocumentid();
			sentenceidcrc= crcnodeext.getSentenceid();
			

			try{
			if(ts.add(Integer.toString(docid_crc)+con+tocon))
			{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}//if
			}catch(Exception e){e.printStackTrace();}
			}//for ends

			
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
		break;

		case 4:
				try {
			transactioncrc = sessioncrc.beginTransaction();
			List<CRCTable5> getCRCNodeinfo = (List<CRCTable5>) sessioncrc.createQuery("from CRCTable5 where fromuwconcept='"+con+"' and touwconcept= '"+tocon+"'").list();
		for (Iterator<CRCTable5> iterator1 = getCRCNodeinfo.iterator(); iterator1.hasNext();) {
				CRCTable5 crcnodeext = (CRCTable5) iterator1.next();
			
				String tamil_wrdc1=crcnodeext.getFromtamilconcept();
				String tamil_wrdc2=crcnodeext.getTotamilconcept();
			nec1=Necheck(c1pos);
			nec2=Necheck(c2pos);
		
			
			String c2=crcnodeext.getTouwconcept() ;
			
			
			tamilword_checkc2=tamilcheck(tamil_wrdc2,c2tamil);
			tamilword_checkc1=tamilcheck(tamil_wrdc1,c1tamil);
			ind_relation=crcnodeext.getRelation();


			crc_weight=	crcnodeext.getWeight();		
			crc_frequency= crcnodeext.getTermfrequency();
			docid_crc= crcnodeext.getDocumentid();
			sentenceidcrc= crcnodeext.getSentenceid();
			

			try{
			if(ts.add(Integer.toString(docid_crc)+con+tocon))
			{
		
				node_details.construtObject(crc_weight,crc_frequency,docid_crc,relation,con,c2,sentid_crc,tamil_wrdc1,tamil_wrdc2);
					if((ind_relation).equals(relation))
					{
						flagRelation = true;
					process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}else 
					{
						flagRelation = false;
						process_crc(tamilword_checkc1,tamilword_checkc2,nec1,nec2,flagRelation,c1_qtag,to_con_tag,mwtag);
					}
			}//if
			}catch(Exception e){e.printStackTrace();}
			}//for ends

		transactioncrc.commit();
		} catch (HibernateException e) {
			transactioncrc.rollback();
			////////////////////System.out.println("Exception in CRC");
			e.printStackTrace();
		} finally {
			sessioncrc.close();
		}
		break;


		}

}
	
	/**
	 * This is the method for ranking concept -relation-concept results
	 *
	 * @param ftc1 boolean flag of query concept1(c1)
	 * @param ftc2 boolean flag of query concept2(c2)
	 * @param fNec1 boolean Named Entity check value(c1) 
	 * @param fNec2 boolean Named Entity check value(c2)
	 * @param flagRelation boolean relation of the query conceptfre
	 * @param  c1tag concept1 querytag
	 * @param  c2tag concept2 querytag
	 * @param  mwtag multiword querytag

	 */
	public void process_crc(boolean ftc1,boolean ftc2,boolean fNec1,boolean fNec2,boolean flagRelation,String c1tag,String c2tag,String mwtag)
	{
		boolean pos_check=false;
		
		double freq_count=0;
		
		Object docDetail[]=DocNodeDetails();
		docDetail[3]=node_details.ind_tamil+":"+node_details.toconTamil;
		docDetail[9]=node_details.ind_tamil+node_details.con;
		try{
		if(ftc1 == true && ftc2 == true)
		{
			
			if((node_details.rel).equals("pos"))
			{
				if((c1tag.equals("QW")&&c2tag.equals("QW"))|| (c1tag.equals("QW")&&c2tag.equals("CQW"))||(c1tag.equals("CQW")&&c2tag.equals("QW"))||(c1tag.equals("CQW")&&c2tag.equals("CQW")))
				{
				freq_count = 1+(0.5 * (node_details.weight));
				pos_check=true;
				}
				
			}
			else
			{
				if(mwtag.contains("MW")&&c1tag.equals("QW")&&c2tag.equals("QW"))
				{
				freq_count = 1+(0.5 * (node_details.weight));
				pos_check=true;
				}
				else{
				freq_count = 0.5 * (node_details.weight);
				
				docDetail[0]=freq_count;
				}
			}

			if(fNec1 == true || fNec2 == true)
			{
				
				if(c1tag.equals("QW")&&c2tag.equals("QW"))
				{
					docDetail[4]="1.11";
					////////////////////////System.out.println("bf crc add"+docDetail[2]);
					crc_QWQW_NElist.add(docDetail);
				}
				else if(c1tag.equals("EQW")&&c2tag.equals("QW"))
				{
					docDetail[4]="6.11";
					crc_EQWQW_NElist.add(docDetail);
				}
				else if(c1tag.equals("QW")&&c2tag.equals("EQW"))
				{
					docDetail[4]="7.11";
					crc_QWEQW_NElist.add(docDetail);
				}
				else
				{
				}
			}

			else if(fNec1 == false && fNec2 == false)
			{
				if(c1tag.equals("QW")&&c2tag.equals("QW"))
				{
					docDetail[4]="1.12";
					////////////////////////System.out.println("bf crc add"+docDetail[2]);
					crc_QWQW_nonNElist.add(docDetail);
				}
				else if(c1tag.equals("EQW")&&c2tag.equals("QW"))
				{
					docDetail[4]="6.12";
					crc_EQWQW_nonNElist.add(docDetail);
				}
				else if(c1tag.equals("QW")&&c2tag.equals("EQW"))
				{
					docDetail[4]="7.12";
					crc_QWEQW_nonNElist.add(docDetail);
				}
				else
				{
				}
			}
			
		}//if QWQW check
		
		else if((ftc1 == true && ftc2 == false))
		{
				if(fNec1 == true || fNec2 == true)
				{
					if(c1tag.equals("QW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="2.11";
						crc_QWCQW_NElist.add(docDetail);
					}
					else if(c1tag.equals("EQW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="7.11";
						crc_EQWCQW_NElist.add(docDetail);
					}
					else
					{
						////////////////////////System.out.println("Query Tag does not mathch");
						////////////////////////System.out.println("c1tag is  :"+c1tag+"  :c2 tag is :"+c2tag);
					}
				}
				if(fNec1 == false || fNec2 == false)
				{
					if(c1tag.equals("QW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="2.12";
						crc_QWCQW_nonNElist.add(docDetail);
					}
					else if(c1tag.equals("EQW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="7.12";
						crc_EQWCQW_nonNElist.add(docDetail);
					}
					else
					{
						
					}
				}
				
		}//else if QWCQW check
		
		else if((ftc1 == false && ftc2 == true))
		{
				if(fNec1 == true || fNec2 == true)
				{
					if(c1tag.equals("CQW")&&c2tag.equals("QW"))
					{
						docDetail[4]="3.11";
						crc_CQWQW_NElist.add(docDetail);
					}
					else if(c1tag.equals("CQW")&&c2tag.equals("EQW"))
					{
						docDetail[4]="7.11";
						crc_CQWEQW_NElist.add(docDetail);
					}
					else
					{
						
					}
				}
				if(fNec1 == false || fNec2 == false)
				{
					if(c1tag.equals("CQW")&&c2tag.equals("QW"))
					{
						docDetail[4]="3.12";
						crc_CQWQW_nonNElist.add(docDetail);
					}
					else if(c1tag.equals("CQW")&&c2tag.equals("EQW"))
					{
						docDetail[4]="7.12";
						crc_CQWEQW_nonNElist.add(docDetail);
					}
					else
					{
					
					}
				}

		}//else if QWCQW check
		else if((ftc1 == false && ftc2 == false))
		{
				if(fNec1 == true && fNec2 == true)
				{
					if(c1tag.equals("CQW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="4.11";
						crc_CQWCQW_NElist.add(docDetail);
					}
					else
					{
						
					}				
				}
				if(fNec1 == true || fNec2 == true)
				{	
					if(c1tag.equals("CQW")&&c2tag.equals("CQW"))
					{
						docDetail[4]="4.12";
						crc_CQWCQW_nonNElist.add(docDetail);
					}
					else
					{
						////////////////////////System.out.println("Query Tag does not mathch");
						////////////////////////System.out.println("c1tag is  :"+c1tag+"  :c2 tag is :"+c2tag);
					}	
				}
				
		}//else if QWCQW check
		}catch(Exception e){////////////////System.out.println("Exception in process crc");
		e.printStackTrace();}
		/*if(flagRelation)
		{
			crcRelList.add(docDetail);
		}*/
	}
	
	
	/**
	 * This is the method for ranking concept -relation results according to the rank tag value assigned to them
	 *
	 * @param flagTamil term of the query check value
	 * @param flagNe POS of query concept check value
	 * @param flagRelation To check relation exists or not
	 * @param c1c2check (Differentiating c1 results/c2 results)
	 * @param qtag query tag of the term of the query 
	 * @param mwtag multiword tag
	 */
	public void process_cr(boolean flagTamil,boolean flagNe,boolean flagRelation,String c1c2check,String qtag,String mwtag)
	{
		double compute_freq=0.0;
		
		Object docDetail[]=DocNodeDetails();
		
		docDetail[9]=node_details.ind_tamil+node_details.con;
		try{
		if(flagTamil==true)
		{
			
			compute_freq = (node_details.weight +node_details.frequency);
			docDetail[0] = 0.3 * (compute_freq) ;
			if(flagNe==true)
			{	
				
	
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW"))
					{
						if(flag_singleword)
						{
						docDetail[4]="5.01";
						}
						else
						{
						docDetail[4]="5.61";
						}
						
						docDetail[7]="QW";
						docDetail[8]="NE";
						c1r_QW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c1r_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
	
				}	
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW"))
					{
						if(flag_singleword)
						{
						docDetail[4]="5.01";
						}
						else
						{
						docDetail[4]="5.61";
						}
						docDetail[7]="QW";
						docDetail[8]="NE";
						c2r_QW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c2r_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c2 process_cr tag violate");
					}
	
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}	
			if(flagNe==false)
			{
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW"))
					{
						if(flag_singleword)
						{
						docDetail[4]="5.02";
						}
						else
						{
						docDetail[4]="5.62";
						}
						docDetail[7]="QW";
						docDetail[8]="nonNE";
						c1r_QW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c1r_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW"))
					{
						if(flag_singleword)
						{
						docDetail[4]="5.02";
						}
						else
						{
						docDetail[4]="5.62";
						}
						docDetail[7]="QW";
						docDetail[8]="nonNE";
						c2r_QW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c2r_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}//ne check
		}//tamil check
		if(flagTamil==false)
		{
			docDetail[0]= 0.3 * (node_details.weight);
			if(flagNe==true)
			{	
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW"))
					{
						docDetail[4]="7.61";
						docDetail[7]="CQW";
						docDetail[8]="NE";
						c1r_CQW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c1r_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
	
				}	
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW"))
					{
						docDetail[4]="7.61";
						docDetail[7]="CQW";
						docDetail[8]="NE";
						c2r_CQW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c2r_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c2 process_cr tag violate");
					}
	
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}	
			if(flagNe==false)
			{
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW"))
					{
						docDetail[4]="7.62";
						docDetail[7]="CQW";
						docDetail[8]="nonNE";
						c1r_CQW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c1r_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW"))
					{
						docDetail[4]="7.62";
						docDetail[7]="CQW";
						docDetail[8]="nonNE";
						c2r_CQW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c2r_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}//ne check
		}		
		/*if(flagRelation)
		{
			crRelList.add(docDetail);
		}*/	
		}catch(Exception e){////////////////System.out.println("Exception in process crc");
		e.printStackTrace();}
	}
	/*
	 * 	To get the results of concepts and term word of the given query
	 * @param con concept of the query
	 * @param check (for differentiating c1 &c2 concepts)
	 * @param tamil query term of the concept 
	 * @param pos query term POS tags
	 * @param qtag query word tag(QW/MW/CW/EQW)
	 */
	
	/*public void getc1c2(String con,String check,String tamil,String pos,String qtag,String mwtag, Session session, Transaction transaction)
	{
		node_details=new nodeDetails();
	
		//int ascV1=(con).hashCode(); 
		boolean flag_tamil=false;
		boolean flag_NE=false;
		//bNodecc=null;
		
		org.apache.nutch.analysis.unl.ta.database.DBConnection dbConnection = new org.apache.nutch.analysis.unl.ta.database.DBConnection();
		 session = HibernateUtil.getSessionFactory().openSession();
		List<Node> conresult = null;
		List<DocInfo> doc_inf = null;
		List<Synonym> tamil_wrd=null;
		//List<Synonym> synid=null
//	Transaction transaction = null;
		int sentenceid = 0;
		int synid=0;
		String str_tamil="";
		try {
			
			transaction = session.beginTransaction();
			
			
	
List<UWInfo> nodeinfo = (List<UWInfo>) session.createQuery("from UWInfo where uwconcept='"+con+"'").list();			
		//////////System.out.println("Input"+con);
			//for(Synonym twrd:tamil_wrd)
		for (Iterator<UWInfo> iterator = nodeinfo.iterator(); iterator.hasNext();) {
			UWInfo uwinfo = (UWInfo) iterator.next();				
			
		
					str_tamil=uwinfo.getTamilconcept();
					synid= dbConnection.getSynonymIdfrmDB(str_tamil);
					//////////System.out.println("Conceptualresult"+str_tamil);
					flag_tamil=tamilcheck(str_tamil,tamil);
					flag_NE=Necheck(pos);
						
			
			doc_inf =  (List<DocInfo>)session.createQuery("from DocInfo where synonymid = '"+synid+"'))").list();
			for (Iterator<DocInfo> iterator_c = doc_inf.iterator(); iterator_c.hasNext();) {
				DocInfo docinfo = (DocInfo) iterator_c.next();
				int dociddb=docinfo.getDocumentid();
				//////////System.out.println("The list of docid"+dociddb+con);
				int freqdb=docinfo.getFrequencycount();
				int weightdb=docinfo.getWeight();
				String sentid= Integer.toString(docinfo.getSentenceid());

		 		node_details.construtObject(weightdb,freqdb,dociddb,"",con,"",sentid,str_tamil,"");	
				////////System.out.println("qtagis"+qtag+mwtag);
				process(flag_tamil,flag_NE,check,qtag,mwtag);	
				
				
			}//for docinfo
			
			}//for for synonym info

		
				
			//}
			transaction.commit();
		} catch (HibernateException e) {
			transaction.rollback();
			e.printStackTrace();
		} finally {
			session.close();
		}

		
	}*/
	/**
	 * To get the result of concept only results and term word results
	 * @param flagTamil query term flag check
	 * @param flagNe Named Entity check
	 * @param c1c2check differentiating c1&c2 check (query term check)
	 * @param qtag query tag
	 * @param mwtag multiword tag
	 */
	
	public void process(boolean flagTamil,boolean flagNe,String c1c2check,String qtag,String mwtag)
	{	
		double compute_freq=0.0;
		Object docDetail[]=DocNodeDetails();
		docDetail[9]=node_details.ind_tamil+node_details.con;
		
		try{
		if(flagTamil==true)
		{
			
			if(mwtag.equals("MW"))
			{
			if(!qtag.equals("EQW"))
			{
			docDetail[4]="1.0";
			docDetail[7]=qtag;
			compute_freq = (node_details.weight +node_details.frequency);
			//////////////////System.out.println("compute_freq"+compute_freq);
			docDetail[0] = 0.2 * (compute_freq) ;
			mwCList.add(docDetail);
			}
		
			}	
			
			else if(flagNe==true)
			{	
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						
						if(flag_singleword)
						{
						docDetail[4]="5.011";
						}
						else
						{
						
						docDetail[4]="5.611";
						}
						docDetail[7]="QW";
						docDetail[8]="NE";
						c1_QW_NElist.add(docDetail);
						////////////////System.out.println("QWNE"+c1_QW_NElist.size());
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c1_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
	
				}	
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						if(flag_singleword == true)
						{
						docDetail[4]="5.012";
						}
						else
						{
						docDetail[4]="5.622";
						}
						docDetail[7]="QW";
						docDetail[8]="NE";
						c2_QW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.71";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c2_EQW_NElist.add(docDetail);
					}
					else
					{
						
					}
	
				}
				else
				{

				}
			
			}	
			else if(flagNe==false)
			{
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						if(flag_singleword )
						{
						docDetail[4]="5.021";
						}
						else
						{
						docDetail[4]="5.711";
						}
						docDetail[7]="QW";
						docDetail[8]="nonNE";
						c1_QW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c1_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						if(flag_singleword)
						{
						docDetail[4]="5.022";
						}
						else
						{
						docDetail[4]="5.722";
						}
						docDetail[7]="QW";
						docDetail[8]="nonNE";
						c2_QW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.72";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c2_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}//ne check
		}//tamil check
		else if(flagTamil==false)
		{
			
			if(mwtag.equals("MW"))
			{
			//if(qtag.equals("QW")||qtag.equals("CQW"))
			if(!qtag.equals("EQW"))
			{
			docDetail[4]="1.0";
			docDetail[7]=qtag;
			compute_freq = (node_details.weight +node_details.frequency);
			//////////////////System.out.println("compute_freq"+compute_freq);
			docDetail[0] = 0.2 * (compute_freq) ;
			mwCList.add(docDetail);
			}
		
			}	
			else
			{
			docDetail[0] = 0.2 * (node_details.weight+node_details.frequency);
			//////////////////System.out.println("docdetail_else"+docDetail[0].toString());
			}
			if(flagNe==true)
			{	
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						docDetail[4]="7.611";
						docDetail[7]="CQW";
						docDetail[8]="NE";
						c1_CQW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.711";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c1_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
	
				}	
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						docDetail[4]="7.612";
						docDetail[7]="CQW";
						docDetail[8]="NE";
						c2_CQW_NElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.712";
						docDetail[7]="EQW";
						docDetail[8]="NE";
						c2_EQW_NElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c2 process_cr tag violate");
					}
	
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}	
			if(flagNe==false)
			{
				
				if(c1c2check.equals("c1"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						docDetail[4]="7.621";
						docDetail[7]="CQW";
						docDetail[8]="nonNE";
						c1_CQW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.721";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c1_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else if(c1c2check.equals("c2"))
				{
					if(qtag.equals("QW")||qtag.equals("CONC"))
					{
						docDetail[4]="7.622";
						docDetail[7]="CQW";
						docDetail[8]="nonNE";
						c2_CQW_nonNElist.add(docDetail);
					}
					else if(qtag.equals("EQW"))
					{
						docDetail[4]="7.722";
						docDetail[7]="EQW";
						docDetail[8]="nonNE";
						c2_EQW_nonNElist.add(docDetail);
					}
					else
					{
						//////////////////////System.out.println(" in c1 process_cr tag violate");
					}
				}
				else
				{
					//////////////////////System.out.println("process_cr c1c2 check fail");
				}
				
			}//ne check
		}			
		}catch(Exception e){////////////////System.out.println("Exception in process crc");
		e.printStackTrace();}
	}
	/***
	andlogic recursive for all terms in the result
	***/
	TreeSet ts_new=new TreeSet();
	public void andlogicforconly(ArrayList c)
	{
		////System.out.println("Inside andlogicforconly"+c.size());
		double andfreq=0;
		
		for(int i=0;i<c.size();i++)
		{
			Object[] cdoc=(Object[])c.get(i);
			int docidc1=(Integer)cdoc[2];
                       double andval=0;
			for(int j=0;j<c.size();j++)
			{
			Object[] cdoc2=(Object[])c.get(j);
			int docidc2=(Integer)cdoc2[2];
			String and_terms="";
			////////System.out.println("Docid"+cdoc[5]+docidc1+"*"+cdoc2[5]+docidc2);
			if(docidc1==docidc2)
			{
                               if(cdoc[8].toString().equals("NE")||cdoc2[8].toString().equals("NE"))
				{
				if(!cdoc[5].equals(cdoc2[5]))
				{
					////////System.out.println("Concepts:"+cdoc[5]+":"+cdoc2[5]);
				if(!cdoc[6].toString().isEmpty()&&!cdoc2[6].toString().isEmpty())
					{
					if( ( (andval=Integer.parseInt(cdoc[6].toString()) & Integer.parseInt(cdoc2[6].toString())) )!= 0 )
					{

							if(!(cdoc[3].toString().contains(":")||cdoc2[3].toString().contains(":")))
						{
							double docfreq1=(Double)cdoc[0];
							double docfreq2=(Double)cdoc2[0];
							andfreq=andfreq+(docfreq1+docfreq2)/2;
							cdoc[0]=andfreq;
							String c1tag=cdoc[7].toString();
							String c2tag=cdoc2[7].toString();
                                                       	String addsuffix_ne="";
							String addsuffix_mw="";
							

							String suffix="";
							if(cdoc[8].toString().equals("NE")&&cdoc2[8].toString().equals("NE"))
							{
								addsuffix_ne="1";
							}
							else if(cdoc[8].toString().equals("NE")||cdoc2[8].toString().equals("NE"))
							{
								addsuffix_ne="2";
							}
							
							suffix="1"+addsuffix_ne;
						//	and_terms=and_terms+cdoc[3].toString()+":"+cdoc2[3].toString()
							//if(ts_new.add(cdoc[3].toString()+docidc1+cdoc2[3].toString()))
							//{
tagPrefix(cdoc[7].toString(),cdoc2[7].toString(),cdoc,cdoc[3].toString()+":"+cdoc2[3].toString(),suffix,cdoc[3].toString()+cdoc[5].toString()+":"+cdoc2[3].toString()+cdoc2[5].toString());
							//}
						}
							
					
					}//if
					}//if
					}//if
				}//if
			}//if
				}//for
		}//for
	}
	/**
	 *This method used to combine the results of c1 concept and c2 concept 
	 * @param c2andlist matched document identifiers for c2 concept
	 * @param c1andlist matched document identifiers for c1 concept
	 * @param check string to check c1 concept or c2 concept
	 */
	TreeSet set=null;
	public void andlogic(ArrayList c2andlist,ArrayList c1andlist,String check)
	{
		
		double andfreq=0;
	double docfreq1=0;
	double docfreq2=0;
	
		try{
		if(c2andlist.size()!=0 &&c1andlist.size()!=0)
		{
		ArrayList doclist=new ArrayList();
		for(int i=0;i<c2andlist.size();i++)
		{
			Object[] c1doc=(Object[])c2andlist.get(i);
			int docid1=(Integer)c1doc[2];
			
			for(int j=0;j<c1andlist.size();j++)
			{
				Object[] c2doc=(Object [])c1andlist.get(j);
				int docid2=(Integer)c2doc[2];
				String c1tag=c1doc[7].toString();
				String c2tag=c2doc[7].toString();

				if(docid1==docid2 & i!=j)
				{
				if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE"))
				{
				
				int andval=0;
				//////////System.out.println("Query terms for AND"+c1doc[5].toString()+c2doc[5].toString()+":"+c1doc[3].toString()+c2doc[3].toString());
				if(!c1doc[5].equals(c2doc[5]))
		
				{
				
					if(!c1doc[6].toString().isEmpty()&&!c2doc[6].toString().isEmpty())
					{
					if( ( (andval=Integer.parseInt(c1doc[6].toString()) & Integer.parseInt(c2doc[6].toString())) )!= 0 )
					{
						
						
					
						
						if(!(c1doc[3].toString().contains(":")||c2doc[3].toString().contains(":")))
						{
							
							docfreq1=(Double)c1doc[0];
							docfreq2=(Double)c2doc[0];
							andfreq=(docfreq1+docfreq2)/2;
							c1doc[0]=andfreq;
							
							String addsuffix_ne="";
							String addsuffix_mw="";
							

							String suffix="";
							if(c1doc[8].toString().equals("NE")&&c2doc[8].toString().equals("NE"))
							{
								addsuffix_ne="1";
							}
							else if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE"))
							{
								addsuffix_ne="2";
							}
							
							
							if(check.equals("xryr"))
							{
								
								suffix="2"+addsuffix_ne;
							////System.out.println("Inside XRYR");
									//if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE")){
								//if(set.add(c1doc[3]+c2doc[3].toString().trim()+docid1)){
								tagPrefix(c1doc[7].toString(),c2doc[7].toString(),c1doc,c1doc[3].toString()+":"+c2doc[3].toString(),suffix,c1doc[3].toString()+c1doc[5].toString()+":"+c2doc[3].toString()+c2doc[5].toString());
							//	}
							//}
							}
							else if(check.equals("xry"))
							{
							////System.out.println("Inside XRY");
								suffix="3"+addsuffix_ne;
								//	if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE")){
							//if(set.add(c1doc[3]+c2doc[3].toString().trim()+docid1)){
								tagPrefix(c1doc[7].toString(),c2doc[7].toString(),c1doc,c1doc[3].toString()+":"+c2doc[3].toString(),suffix,c1doc[3].toString()+c1doc[5].toString()+":"+c2doc[3].toString()+c2doc[5].toString());
								//}
							}
							else if(check.equals("yrx"))
							{
							////System.out.println("Inside YRX");
								suffix="4"+addsuffix_ne;
								//if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE")){
					//	if(set.add(c1doc[3]+c2doc[3].toString().trim()+docid1)){
								tagPrefix(c1doc[7].toString(),c2doc[7].toString(),c1doc,c1doc[3].toString()+":"+c2doc[3].toString(),suffix,c1doc[3].toString()+c1doc[5].toString()+":"+c2doc[3].toString()+c2doc[5].toString());
//}
						//}
							}
							else if(check.equals("xy"))
							{
							////System.out.println("Inside XY");
								
								suffix="5"+addsuffix_ne;
									//if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE")){
							//if(set.add(c1doc[3]+c2doc[3].toString().trim()+docid1)){
								tagPrefix(c1doc[7].toString(),c2doc[7].toString(),c1doc,c1doc[3].toString()+":"+c2doc[3].toString(),suffix,c1doc[3].toString()+c1doc[5].toString()+":"+c2doc[3].toString()+c2doc[5].toString());
					//}

							}
							}
							else
							{
								//////////System.out.println("Inside ELSEAND");
							}
							if((c1tag.equals("QW")&&c2tag.equals("QW")))
							{
								if(table.containsKey(docid1))
								{
									
									set=(TreeSet)table.get(docid1);
									if(set.add(c1doc[5]))
									{
										if(andFreq.containsKey(docid1))
										{
											double add=(Double)andFreq.get(docid1);
											add+=docfreq1;
											andFreq.put(docid1,add);
										}
										else
										{
											andFreq.put(docid1,c1doc[0]);
										}
									}
									if(set.add(c2doc[5]))
									{	
										if(andFreq.containsKey(docid1))
										{
											double add=(Double)andFreq.get(docid1);
											add+=docfreq2;
											andFreq.put(docid1,add);
										}
										else
										{
											andFreq.put(docid1,c2doc[0]);
										}
									}
									
									table.put(docid1,set);
								}
								else
								{
									set=new TreeSet();
									
									set.add(c1doc[5]);
									set.add(c2doc[5]);
									andFreq.put(docid1,andfreq);
									table.put(docid1,set);
								}
							}
							
						}
					}
					//}//sentence id
				} //tamil word not equal
				}// duplicate chk
				}
			} //doc contains
		}//for
		}//if null chk
		}catch(Exception e){////////////////System.out.println("Exception in ANDLogic");
		e.printStackTrace();}
		andlogicCnt++;
	}
	public boolean crc_AND=false;
//TreeSet rem_dup=new TreeSet();
	public void andlogic_crc(ArrayList c2andlist,ArrayList c1andlist,String check)
	{
		//////////////////System.out.println("I am inCRC AND1");
		double andfreq=0;
		TreeSet set=null;
		
		if(c2andlist.size()!=0 &&c1andlist.size()!=0)
		{
		if(c2andlist.size()!=0 &&c1andlist.size()!=0)
		{
		ArrayList doclist=new ArrayList();
		for(int i=0;i<c2andlist.size();i++)
		{
			Object[] c1doc=(Object[])c2andlist.get(i);
			int docid1=(Integer)c1doc[2];
			for(int j=0;j<c1andlist.size();j++)
			{
				Object[] c2doc=(Object [])c1andlist.get(j);
				int docid2=(Integer)c2doc[2];
				if(docid1==docid2 & i!=j)
				{
					////////////////System.out.println("Yes i am inside1");		
				int andval=0;
				
			////////////////System.out.println("Yes i am inside2");
			if((c1doc[3].toString().contains(":")||c2doc[3].toString().contains(":")))
		
			{
			////System.out.println("AFTR CONCHECK CRC");
				/*String[] conandtamilword=c1doc[3].toString().split(":");
				String c1concept=conandtamilword[0];
				String c2concept=conandtamilword[0];*/
				////////////////System.out.println("C1andC2"+c1doc[5].toString()+"\t"+c2doc[5].toString()+"\t"+c2doc[10].toString()+"\t"+c1doc[10].toString());
				if(!c1doc[5].toString().trim().equals(c2doc[5].toString().trim()) && !c1doc[10].toString().trim().equals(c2doc[10].toString().trim()) &&!c1doc[6].toString().isEmpty()&&!c2doc[6].toString().isEmpty())
				{
				crc_AND=true;
				////////////////System.out.println("CRCAND"+crc_AND);
		
				if( ( (andval=Integer.parseInt(c1doc[6].toString()) & Integer.parseInt(c2doc[6].toString())) )!= 0 )
				{
				double docfreq1=(Double)c1doc[0];
							double docfreq2=(Double)c2doc[0];
							andfreq=(docfreq1+docfreq2)/2;
							c1doc[0]=andfreq;
							String c1tag=c1doc[7].toString();
							String c2tag=c2doc[7].toString();
							String addsuffix="";
							String suffix="";
							if(c1doc[8].toString().equals("NE")&&c2doc[8].toString().equals("NE"))
							{
								addsuffix="";
							}
							else if(c1doc[8].toString().equals("NE")||c2doc[8].toString().equals("NE"))
							{
								addsuffix="1";
							}
							else
							{
								addsuffix="2";
							}
							if(check.equals("xryx1ry1"))
							{
								
						
								suffix="1"+addsuffix;
//if(rem_dup.add(c1doc[3].toString()+c2doc[3].toString()+docid2))
{						
	tagPrefix(c1doc[7].toString(),c2doc[7].toString(),c1doc,c1doc[3]+":"+c2doc[3],suffix,c1doc[3].toString()+c1doc[5].toString()+":"+c2doc[3].toString()+c2doc[5].toString()+c1doc[10].toString()+c1doc[11].toString()+":"+c2doc[10].toString()+c2doc[11].toString());
}
							}
							if((c1tag.equals("QW")&&c2tag.equals("QW")))
							{
								if(table.containsKey(docid1))
								{
									
									set=(TreeSet)table.get(docid1);
									if(set.add(c1doc[5]))
									{
										if(andFreq.containsKey(docid1))
										{
											double add=(Double)andFreq.get(docid1);
											add+=docfreq1;
											andFreq.put(docid1,add);
										}
										else
										{
											andFreq.put(docid1,c1doc[0]);
										}
									}
									if(set.add(c2doc[5]))
									{	
										if(andFreq.containsKey(docid1))
										{
											double add=(Double)andFreq.get(docid1);
											add+=docfreq2;
											andFreq.put(docid1,add);
										}
										else
										{
											andFreq.put(docid1,c2doc[0]);
										}
									}
									
									table.put(docid1,set);
								}
								else
								{
									set=new TreeSet();
									set.add(c1doc[5]);
									set.add(c2doc[5]);
									set.add(c1doc[10]);
									set.add(c2doc[10]);
									andFreq.put(docid1,andfreq);
									table.put(docid1,set);
								}
								}
				

				
			}//CRC aND
			}//if Closer to each other
			}//if for docid similarity	
			}//for
		}//for
		}//if
		
		}//if
		}
	}//end
	/**
	 * This method used to add additional value to the rank tag by considering the frequency count and position weight
	 * @param c1tag concept1 query tag
	 * @param c2tag concept2 query tag
	 * @param c1doc matched documents for concept1 query term
	 * @param c1_tamil query term of c1concept
	 * @param suffix tag suffix
	 * @param highlight the concept word which needs to be highlighted in the snippet
	 */
	public void tagPrefix(String c1tag,String c2tag,Object[] c1doc,String c1_tamil,String suffix,String highlight)
	{
		String tag="";
		Object [] docDetail=new Object[9];
		docDetail=c1doc;
	      //////////System.out.println("c1tag"+c1_tamil+";"+c1tag+"\t"+"c2tag"+c2tag+suffix);
		////////System.out.println("andfreq in tagprefix is="+c1doc[4]);
		if(c1tag.equals("QW")&&c2tag.equals("QW")||c1tag.equals("CONC")&&c2tag.equals("CONC"))
		{
			tag="1."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_QWQW_list.add(docDetail);
		}
		else if(c1tag.equals("QW")&&c2tag.equals("CQW"))
		{
			tag="2."+suffix;
			
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_QWCQW_list.add(docDetail);
		}
		else if(c1tag.equals("CQW")&&c2tag.equals("QW"))
		{
			tag="3."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
		}
		else if(c1tag.equals("CQW")&&c2tag.equals("CQW"))
		{
			tag="4."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_CQWCQW_list.add(docDetail);
		}
		else if(c1tag.equals("QW")&&c2tag.equals("EQW"))
		{
			
			tag="6."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_QWEQW_list.add(docDetail);
		}
		else if(c1tag.equals("EQW")&&c2tag.equals("QW"))
		{
			
			tag="6."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_EQWQW_list.add(docDetail);
			
		}
		else if(c1tag.equals("CQW")&&c2tag.equals("EQW"))
		{
			tag="7."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_CQWEQW_list.add(docDetail);
		}
		else if(c1tag.equals("EQW")&&c2tag.equals("CQW"))
		{
			tag="7."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_EQWCQW_list.add(docDetail);
		}
		else if(c1tag.equals("EQW")&&c2tag.equals("EQW"))
		{
			tag="7."+suffix;
			docDetail[3]=c1_tamil;
			docDetail[4]=tag;
			docDetail[9]=highlight;
			and_EQWCQW_list.add(docDetail);
		}
		else
		{
			
		}
	TreeSet sett=(TreeSet)table.get(docDetail[2]);
		if(sett!=null)
		{
			if(sett.size()>2)
			{
				String tamilword="";
				highlight="";
				 Iterator i = sett.iterator();
				while (i.hasNext()) {
				String concpt=(String)i.next();
				String word=(String)hashtable_c.get(concpt);
					if(word!=null)
					{
				   		tamilword+=word+" : ";
						highlight+=word+concpt+":";
					}
				}
				
				tag="1";
				c1doc[0]=(Double)andFreq.get(docDetail[2]);
				c1doc[3]=tamilword;
				//////////System.out.println("Inside >2"+c1doc[3].toString());
				c1doc[4]=tag;
				docDetail[9]=highlight;
				and_QWQW_list.add(c1doc);
			}
		}
		
		c1_tamil=null;
	}
	/**
	 * This method used to check actual query term and it's concepts 
	 * @param tamilword String tamil word of the term in the index
	 * @param givenword actual query term given by user
	 * @return boolean
	 */
	public boolean tamilcheck(String tamilword,String givenword)
	{
		if(tamilword.equals(givenword))
		{
			return true;
		}
		return false;
	}
	/**
	 * This method used to check for the c1,c2 concepts are Named Entity or Not 
	 * @param poscheck
	 * @return boolean
	 */
	public boolean Necheck(String poscheck)
	{
		if(poscheck.equals("Entity")||poscheck.equals("Non Tamil Noun"))
		{
			return true;
		}
		return false;
	}
	/**This method return the Document Node details of the matched query term 
	 * @return docDetail_bnode object of matched query term document id,pos weight,freqency weight 
	 */
	public Object[] DocNodeDetails()
	{
		TreeSet set=new TreeSet();		
		Object[] docDetail_bnode = new Object[12];
		docDetail_bnode[0] = node_details.frequency; //frequency
		docDetail_bnode[1] ="";	//
		docDetail_bnode[2] =node_details.docid; //docid
		docDetail_bnode[3] =node_details.ind_tamil; //tamilword
		docDetail_bnode[4] =""; //ranktag
		docDetail_bnode[5] =node_details.con; //concept
		docDetail_bnode[6] =node_details.senid; //sentid
		docDetail_bnode[7] =""; //querytag
		docDetail_bnode[8] =""; //NE chk
		docDetail_bnode[9] =""; //for snippet highlight

		docDetail_bnode[10] =node_details.tocon; 
		docDetail_bnode[11] =node_details.toconTamil;
		
		
		return docDetail_bnode;
	}

	/**
	 * This method used to sort the documents with respect to the frequency count and 
	 * position value of the concept
	 * @param al_weight
	 * @return rankresult
	 */
	public ArrayList Freq_Sorting(ArrayList al_weight)
	{
		
	
		Object [] bfSort=new Object[al_weight.size()];
		double sumoffreq=0.0;
		for(int i=0;i< al_weight.size();i++)
		{
			
			Object docinfo[] = (Object[])al_weight.get(i);
			Object hit[] = new Object[9];
		
					hit[0]=""; //url
					hit[1]=docinfo[2];//docid
					hit[2]="";//snippet
					hit[3]=docinfo[4];//ranktag
					hit[4]=docinfo[3];//queryword
					hit[5]= docinfo[5];//con
					hit[6]=docinfo[7]; //query tag
					hit[7]=docinfo[0];//frequency
					hit[8]=docinfo[9];//frequency
					
			bfSort[i]=hit;
		}
			
			for(int i=0;i<bfSort.length;i++)
			{
				Object [] doc1=(Object [])bfSort[i];
				String ranktag1=doc1[3].toString();
				String queryTag=doc1[6].toString();
				String query_word=doc1[4].toString();
				double freq1=(Double)doc1[7];

				for(int j=0;j<bfSort.length;j++)
				{	
		
					Object [] doc2=(Object [])bfSort[j];
					String ranktag2=doc2[3].toString();
					double freq2=(Double)doc2[7];
					
					
				if(ranktag1.startsWith("5.0")){
					if(queryTag.equals("QW"))
					{
						if(freq1>freq2)
						{
						
							Object [] o=(Object[])bfSort[i];
							bfSort[i]=bfSort[j];
							bfSort[j]=o;	
						}
					
					}
				}
				else
				{
					
					if(ranktag1.equals(ranktag2))
					{
						if(freq1>freq2)
						{
						
							Object [] o=(Object[])bfSort[i];
							bfSort[i]=bfSort[j];
							bfSort[j]=o;	
						}
					
					}
					
				}
				}
			}
			List list=Arrays.asList(bfSort);
			ArrayList rankresult=new ArrayList(list);
			
			for(int i=0;i<bfSort.length;i++)
			{	
				Object o[]=(Object[])bfSort[i];
				////////////////System.out.println("The url"+o[1].toString());
				
			}
		freqSortingCnt++;
		return rankresult;
	}
	/**
	 * This method used for sorting the results with respect to the rank tag
	 * @param rank matched results with rank tag
	 * @return ranked results
	 */	
	public ArrayList tagSorting(ArrayList rank)
	{	
		
		ArrayList sortconcept=new ArrayList();
		
		double weight[]=new double[rank.size()];
		
		for(int i=0;i< rank.size();i++)
		{
			
			Object docinfo[] = (Object[])rank.get(i);
			
			String str=(String)docinfo[4];
		//	////////System.out.println("STR inside TAG SORTING:"+rank.get(i).toString()+"=========>"+str);
			
			try
			{			
				weight[i]=Double.parseDouble(str);
			
			}
			catch(Exception e)
			{
			}
		}
		
		Object alweight[]=rank.toArray();
		Object temp[]=new Object[rank.size()];
		double temp1=0;
		for(int i=0;i<weight.length;i++)
		{

			for(int j=0;j<weight.length;j++)
			{				
				if(weight[i]<weight[j])
				{
					
					Object [] o=(Object[])alweight[i];
					alweight[i]=alweight[j];
					alweight[j]=o;
					temp1=weight[i];
					weight[i]=weight[j];
					weight[j]=temp1;
					
				}
			}
		}
		List list=Arrays.asList(alweight);
		ArrayList rankresult=new ArrayList(list);
		for(int i=0;i<rankresult.size();i++)
		{
		Object obj[]=(Object[])rankresult.get(i);
		////////////System.out.println("The list of object"+obj[4]);
		
		}
		tagSortingCnt++;
		return rankresult;
	}
	/**
	 * This method gets the url for the document identifer for the matched documents
	 * @param al_rank
	 * @return get_url
	 */
	public ArrayList getNodeLink(ArrayList al_rank)
	{
   
		ArrayList get_url=new ArrayList();
		//////////////////////System.out.println("al_rank size"+al_rank.size());
	      try
	      {	
			for(int i=0;i<al_rank.size();i++)
			{
				Object[] info=(Object[])al_rank.get(i);
			 	StringBuffer sbresult  = new StringBuffer();
				//////////////////System.out.println("Before Accessing"+info[1].toString());
				
				
				String str2 = (String)fileList.get("d"+info[1].toString().trim());
				info[0]=str2;
				//////////////System.out.println("INFO"+info[0]+"DOCID"+info[1].toString());
				if(info[0]!=null){
				get_url.add(info);
				
				}
				
			}//for loop ends 
	     	}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		getNodeLinkCnt++;
	     	return get_url;
	}
	
	
	
	/**This method used to generate Snippet
	 * @param input url is given as input
	 * @return output snippet
	 */
	public String contentprocess(String input)
	{
		int findpl=0;
		String output="";
		String[] spt=input.split(" ");
		for(String s:spt)
		{
			output=output+s+" ";
			findpl++;
			if(findpl==21)
				break;
		}
		return output;
	}
	/**
	 * This method remove duplicates without changing the order
	 * @param arlList passing the final ranked result
	 * @return newList final ranked results
	 */
	public ArrayList removeDuplicateWithOrder(ArrayList arlList)
	{
		//////////////////////System.out.println("In remove duplicate"+arlList.size());
		 TreeSet set = new TreeSet();
		 ArrayList newList = new ArrayList();
		 for (int i=0;i<arlList.size();i++ )
		 {
			//////////////////////System.out.println("Inside for");
               		Object[] element = (Object[])arlList.get(i);
			int docid1=(Integer)element[2];
			//////////////////////System.out.println("docid in dup chk  :"+element[2]);
			if (set.add(""+element[2]))
			{
				
		      		newList.add(element);
				//////////////////////System.out.println("doc added");
			}
    		}
		removeDuplicateCnt++;
		////////////////System.out.println("List of URL"+newList.size());
		return newList;
	}
	
	/***
	 * To put the query terms which are verb or finite verb
	 */
	public void querywordHashtable(FinalLLImpl[] llq)
	{
				//llq=TamilQueryGraph.multilist_UNLQuery();
							
				temp3=llq[0].head;
				cpt1=temp3.colnext;
				
				while(cpt1 != null)
				{
						
					
				
				     if((!(cpt1.poscheck.equals("Verb"))) && (!(cpt1.poscheck.equals("Finite Verb"))))
					{
						hashtable_c.put(cpt1.uwconcept,cpt1.gn_word);
						
					}	//if
					cpt1=cpt1.getColNext();
					////////////////////System.out.println("Hashtable="+hashtable_c);
				}//while
			
		
	}
	/**
	 * Method for getting the actual tamil term of the concept 2(c2)
	 * @param uwconcept c2 concept as string
	 * @return the actual tamil term of the c2 concept
	 */
	public String getQW(String uwconcept)
	{
			//////System.out.println("uwconcept"+uwconcept);
			return ((String)hashtable_c.get(uwconcept));
	}
	/**
	 * Get the Hit results from the cache
	 * @param query actual query term of the concept
	 * @return list of ranked results
	 */
	public static ArrayList catcheHit(String query)
	{
		Enumeration names=null;
		ArrayList list=null;
		int counter=0;
		////////////////////System.out.println("Cachehit method is called....");
		if(cache.size()!=0)
		{
			if(cache.containsKey(query))
			{
				////////////////////System.out.println("Query exist in cache..");
				Hashtable value=(Hashtable)cache.get(query);
				names = value.keys(); 
				if(names.hasMoreElements())
				{
					String str=(String)names.nextElement();
					list =(ArrayList)value.get(str);
					////////////////////System.out.println("Query exist in cache.."+list.size());
					counter=Integer.parseInt(str);
					counter++;
					value.put(counter,list);
				}
			}
		}
		
		return list;
	}
	/**
	 * This method used to seperate the tag for matrix display of the user interface
	 * @param list final ranked list of matched documents
	 * @return finalList final list of ranked documents seperated in different tag value
	 */
		public static ArrayList seperateTag(ArrayList list)
	{
		//Changes given to get the conceptual results
		ArrayList finalList=new ArrayList();
		ArrayList tag1=new ArrayList();
		ArrayList tag23=new ArrayList();
		ArrayList tag4=new ArrayList();
		ArrayList tag5=new ArrayList();
		ArrayList tag67=new ArrayList();
		for(int i=0;i<list.size();i++)
		{
			Object obj[]=(Object[])list.get(i);
			
			String tag=obj[3].toString();
			//////////System.out.println("Tag"+tag+":"+obj[4].toString());
			/*if(tag.contains(".1")||tag.startsWith("1"))
			{
				if(!tag.contains("5")&&!tag.contains("6")&&!tag.contains("7"))
				{

				tag1.add(obj);
				}
			}
			else if(tag.contains(".2")||tag.contains("3"))
			{
				if(!tag.contains("5")&&!tag.contains("6")&&!tag.contains("7"))
				{
				tag23.add(obj);
				}
			}
			else if(tag.contains(".4"))
			{
				if(!tag.contains("5")&&!tag.contains("6")&&!tag.contains("7"))
				{
				tag4.add(obj);
				}
			}
			else if(tag.startsWith("5")||tag.startsWith("6"))
			{
				
						tag56.add(obj);
				
				
			}
			else if(tag.startsWith("7"))
			{
				
				tag7.add(obj);
				
			}
			else
			{
				////////////////////System.out.println("No match..");
			}*/
			if(tag.startsWith("1"))
			{
				tag1.add(obj);
			}
			else if(tag.startsWith("2")||tag.startsWith("3"))
			{
				tag23.add(obj);
			}
			else if(tag.startsWith("4"))
			{
				tag4.add(obj);
			}
			else if(tag.startsWith("5"))
			{
				
				tag5.add(obj);
			}
			else if(tag.startsWith("6") || tag.startsWith("7"))
			{
				tag67.add(obj);
			}
			else
			{
				//////////////System.out.println("No match..");
			}

		}
		//if(tag1.size()!=0)
		{
			finalList.add(tag1);
		}
		// if(tag23.size()!=0)
		{
			finalList.add(tag23);
		}
		// if(tag4.size()!=0)
		{
			finalList.add(tag4);
		}
		//if(tag56.size()!=0)
		{
			finalList.add(tag5);
		}
		//if(tag7.size()!=0)
		{
			finalList.add(tag67);
		}
		return finalList;
	}
		
}
/**
 * 
 * @author Umamaheswari E
 * This class contains the details of node for the matched concept in the index tree
 *
 */
class nodeDetails
{
	public nodeDetails()
	{
		con = null;
        	rel = null;
		tocon = null;
        	ind_tamil = null;
        	docid = 0;
        	senid = null;
        	weight = 0;
        	frequency = 0;
		toconTamil=null;
	}
	public String con;
    	public String rel;
	public String tocon;
    	public String ind_tamil;
    	public int docid;
    	public String senid;
    	public int weight;
    	public double frequency;
	public double ranktag;
	public String toconTamil;
	/**
	 * 
	 * @param wight concept position weight
	 * @param freq frequency count of concepts and terms
	 * @param dociD document identifier
	 * @param relation relation identifier
	 * @param concpt query concept
	 * @param sentid position of the concept in a sentence 
	 * @param in_tamil actual query term of the conept
	 */
    	public void construtObject(int wight,int freq,int dociD,String relation,String concpt,String toconcept,String sentid,String in_tamil,String totamil)
    	{
		////System.out.println(" Construct Object"+wight+"\t"+frequency+"\t"+dociD+"\t"+relation+"\t"+concpt+"\t"+toconcept+"\t"+sentid+"\t"+in_tamil+"\t"+totamil);
    		con = concpt;
        	rel = relation;
		tocon = toconcept;
        	ind_tamil = in_tamil;
        	docid = dociD;
        	senid = sentid;
        	weight = wight;
        	frequency = freq;
		toconTamil = totamil;
		
		
	}
}
